////bin/dukhep_create_reader.py -n MuonReader ../Macros/MuonReaderMacro.dat
#include "include/MuonReader.h"

MuonReader::MuonReader(SCycleBaseNTuple * ownr, const char * collname): owner(ownr), cname(collname),
m_MuonAuthor(0),
m_MuonEta(0),
m_MuonIsoPtCone30(0),
m_MuonIsoEtCone30(0),
m_MuonE(0),
m_MuonPt(0),
m_MuonPhi(0),
m_MuonExpectBLayerHit(0),
m_MuonBLayerHits(0),
m_MuonNumPixelHits(0),
m_MuonNumPixelDeadSensors(0),
m_MuonNumSCTHits(0),
m_MuonNumSCTDeadSensors(0),
m_MuonNumPixHoles(0),
m_MuonNumSCTHoles(0),
m_MuonNumTRTHits(0),
m_MuonNumTRTOutliers(0),
m_NumMuons(0),
m_StacoMuonTrackQOverP(0),
m_StacoMuonTrackPhi(0),
m_StacoMuonTrackTheta(0)
{std::cout << "MuonReader: Collection name is " << cname << std::endl;}

void MuonReader::ConnectVariables(std::string treename){
  owner->ConnectVariable( treename.c_str(), VarName("mu_author").c_str(), m_MuonAuthor );
  owner->ConnectVariable( treename.c_str(), VarName("mu_eta").c_str(), m_MuonEta );
  owner->ConnectVariable( treename.c_str(), VarName("mu_ptcone30").c_str(), m_MuonIsoPtCone30 );
  owner->ConnectVariable( treename.c_str(), VarName("mu_etcone30").c_str(), m_MuonIsoEtCone30 );
  owner->ConnectVariable( treename.c_str(), VarName("mu_E").c_str(), m_MuonE );
  owner->ConnectVariable( treename.c_str(), VarName("mu_pt").c_str(), m_MuonPt );
  owner->ConnectVariable( treename.c_str(), VarName("mu_phi").c_str(), m_MuonPhi );
  owner->ConnectVariable( treename.c_str(), VarName("mu_expectBLayerHit").c_str(), m_MuonExpectBLayerHit );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nBLHits").c_str(), m_MuonBLayerHits );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nPixHits").c_str(), m_MuonNumPixelHits );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nPixelDeadSensors").c_str(), m_MuonNumPixelDeadSensors );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nSCTHits").c_str(), m_MuonNumSCTHits );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nSCTDeadSensors").c_str(), m_MuonNumSCTDeadSensors );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nPixHoles").c_str(), m_MuonNumPixHoles );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nSCTHoles").c_str(), m_MuonNumSCTHoles );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nTRTHits").c_str(), m_MuonNumTRTHits );
  owner->ConnectVariable( treename.c_str(), VarName("mu_nTRTOutliers").c_str(), m_MuonNumTRTOutliers );
  owner->ConnectVariable( treename.c_str(), VarName("mu_n").c_str(), m_NumMuons );
  owner->ConnectVariable( treename.c_str(), VarName("mu_staco_trackqoverp").c_str(), m_StacoMuonTrackQOverP );
  owner->ConnectVariable( treename.c_str(), VarName("mu_staco_trackphi").c_str(), m_StacoMuonTrackPhi );
  owner->ConnectVariable( treename.c_str(), VarName("mu_staco_tracktheta").c_str(), m_StacoMuonTrackTheta );
}
void MuonReader::DeclareVariables(){
  owner->DeclareVariable( o_m_MuonAuthor, "mu_author" );
  owner->DeclareVariable( o_m_MuonEta, "mu_eta" );
  owner->DeclareVariable( o_m_MuonE, "mu_E" );
  owner->DeclareVariable( o_m_MuonPt, "mu_pt" );
  owner->DeclareVariable( o_m_MuonPhi, "mu_phi" );
  owner->DeclareVariable( o_m_NumMuons, "mu_n" );
}
void MuonReader::Reset(){
 o_m_MuonAuthor.clear();
 o_m_MuonEta.clear();
 o_m_MuonE.clear();
 o_m_MuonPt.clear();
 o_m_MuonPhi.clear();
 o_m_NumMuons= -999;
  }
void MuonReader::CopyToOutput(){
 o_m_MuonAuthor = std::vector<int>(*m_MuonAuthor);
 o_m_MuonEta = std::vector<float>(*m_MuonEta);
 o_m_MuonE = std::vector<float>(*m_MuonE);
 o_m_MuonPt = std::vector<float>(*m_MuonPt);
 o_m_MuonPhi = std::vector<float>(*m_MuonPhi);
 o_m_NumMuons = m_NumMuons;
  }

bool MuonReader::IsGoodMuon(unsigned int il, float etmin) {
  if (m_MuonAuthor->at(il) != 12) return false;
  if (GetMuonTransverseMomentum(il) <= etmin) return false;
  float eta = TMath::Abs(m_MuonEta->at(il));
  if (eta >= 2.5) return false;
  if ( not ( !m_MuonExpectBLayerHit->at(il) || 0 != m_MuonBLayerHits->at(il) )) return false;
  if (m_MuonNumPixelHits->at(il) + m_MuonNumPixelDeadSensors->at(il) < 2) return false;
  if (m_MuonNumSCTHits->at(il) + m_MuonNumSCTDeadSensors->at(il) < 6) return false;
  if (m_MuonNumPixHoles->at(il) + m_MuonNumSCTHoles->at(il) > 1) return false;
  float n = m_MuonNumTRTHits->at(il) + m_MuonNumTRTOutliers->at(il);
  if (eta < 1.9) {
    if (not ((n > 5) && (m_MuonNumTRTOutliers->at(il)/n < 0.9))) return false;
  } else {
    if ((n > 5) && (m_MuonNumTRTOutliers->at(il)/n >= 0.9)) return false;
  }
  if (m_MuonIsoPtCone30->at(il) >= 4000 || m_MuonIsoEtCone30->at(il) >= 4000) return false;
  return true;
}
