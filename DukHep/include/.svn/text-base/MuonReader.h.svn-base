////bin/dukhep_create_reader.py -n MuonReader ../Macros/MuonReaderMacro.dat
#ifndef MUONREADER
#define MUONREADER 1
#include <vector>
#include <string>
#include <iostream>
#include "core/include/SCycleBaseNTuple.h"
#include "DukHep/include/DukHepFilter.h"
#include "TLorentzVector.h"

class MuonReader {
  public:
  MuonReader(SCycleBaseNTuple * o, const char* collname="mu");
    virtual ~MuonReader(){};
    void SetColl(const char * collname) {
      cname = std::string(collname);
      std::cout << "Using muon collection name " << cname << std::endl;
    };
    std::string VarName(const char * s) {
      std::string tmp(s); 
      if ((tmp.find("mu_")==0) && (tmp.find("staco")!=3) && (tmp.find("muid")!=3))
	return std::string(tmp.replace(0,2,cname)); 
      return std::string(s);
    }
    void ConnectVariables(std::string treename);
    void DeclareVariables();
    void Reset();
    void CopyToOutput();

    //define your getters here
    bool IsGoodMuon(unsigned int il, float etmin=25000);
    int CountGoodMuons(float etmin=25000)
    {int count(0), i(0); for (; i<m_NumMuons; ++i) if (IsGoodMuon(i,etmin)) ++count; return count;}
    float GetDeltaR(unsigned int il, float othereta, float otherphi) {
      return DukHepFilter::deltaREtaPhi(m_MuonEta->at(il)-othereta,m_MuonPhi->at(il)-otherphi);
    }
    float GetMuonTransverseMomentum(unsigned int il) { return m_MuonPt->at(il); };
    void FillMuonFourMomentum(unsigned int il, TLorentzVector & vl) 
    { vl.SetPtEtaPhiE(m_MuonPt->at(il),m_MuonEta->at(il),m_MuonPhi->at(il),m_MuonE->at(il));}
    bool MuonMatchesTrigger(unsigned int il) {
      return true;
    }
  public:
    SCycleBaseNTuple * owner;    
    std::string cname;
      std::vector<int>* m_MuonAuthor;
  std::vector<int> o_m_MuonAuthor;
  std::vector<float>* m_MuonEta;
  std::vector<float> o_m_MuonEta;
  std::vector<float>* m_MuonIsoPtCone30;
  std::vector<float>* m_MuonIsoEtCone30;
  std::vector<float>* m_MuonE;
  std::vector<float> o_m_MuonE;
  std::vector<float>* m_MuonPt;
  std::vector<float> o_m_MuonPt;
  std::vector<float>* m_MuonPhi;
  std::vector<float> o_m_MuonPhi;
  std::vector<int>* m_MuonExpectBLayerHit;
  std::vector<int>* m_MuonBLayerHits;
  std::vector<int>* m_MuonNumPixelHits;
  std::vector<int>* m_MuonNumPixelDeadSensors;
  std::vector<int>* m_MuonNumSCTHits;
  std::vector<int>* m_MuonNumSCTDeadSensors;
  std::vector<int>* m_MuonNumPixHoles;
  std::vector<int>* m_MuonNumSCTHoles;
  std::vector<int>* m_MuonNumTRTHits;
  std::vector<int>* m_MuonNumTRTOutliers;
  Int_t m_NumMuons;
  Int_t o_m_NumMuons;
  std::vector<float>* m_StacoMuonTrackQOverP;
  std::vector<float>* m_StacoMuonTrackPhi;
  std::vector<float>* m_StacoMuonTrackTheta;
};
 #endif
